[{"content":"Dependent types, refinement types, gradual types, rank-n polymorphism, etc, \u0026ndash; we are moving in the right direction\nLet\u0026rsquo;s dream a bit and try to imagine what can be improved about type systems. Ability to limit and check variables and function arguments at compile time multiplies development speeds by dozens of times, but modern type systems are STILL not expressive enough - you mostly can filter out only quite basic errors. Functional programmers excel at making the wrong state inexpressible in terms of the type system, but static type systems still can\u0026rsquo;t encode very complex logic and relations.\nWell, they do, but it is absolutely unusable for casual coding, fast prototyping, and most industrial use cases.\nIn certain fields, such as game development, the amount of rules gets crazy, and most interactions of related game mechanics can\u0026rsquo;t even be covered with tests, not to mention types. But possibly this is only because type systems are too restrictive. They don\u0026rsquo;t allow embedding crazy expressions from the the value level. Yet.\nPossible Improvements For Type Systems  Types should be first-class objects. There should be convenient type lambdas Types should be allowed to contain value-level expressions (Refinement Types) Moreover, types could contain runtime values (Gradual Types) The same code should be usable both at compile time and execution time There should be runtime conditional expressions for type checks All definitions and type specifications should share context with the code they\u0026rsquo;re in Type intersection is a fundamental operation for composing types BONUS: Types, sets, and functions should be unified with T̷y̷p̴e̷ ̵Fi̵l̷t̸e̵r̸s̴ BONUS: I̸n̵v̶e̵r̶s̶e̷ f̵un̸c̴t̵i̴o̷n̴s̸ ̵s̵h̵o̸u̸l̸d̶ ̶e̷a̴s̶e̶ work with ̷a̴l̷l t̵y̷p̵e̸ ̴s̴p̵e̴c̵i̸f̵i̴c̵a̵t̷i̸o̵n̴s (next post) BONUS: Type/value union is another fundamental operation for representing indeterminism  What in the name of satan is all of that? Possibly, I\u0026rsquo;ll explain everything in the next blog posts, but this time, let\u0026rsquo;s just review some examples.\nNotation I\u0026rsquo;ll use pseudocode in some semi-esoteric language for clarity. It\u0026rsquo;s very expressive, so if you want something more conventional, you can change to pseudo-C++ or pseudo-Haskell in every code example - see tabs above code blocks. But I suggest to glimpse through all three.\nIn this section, I\u0026rsquo;ll explain shortly how to read the ideas described in this post.\nFirstly, this is how type intersection is done. This would be a fundamental operation for composing types.\npseudocode cpp haskell  myVariable: MyType1 MyType2 \u0026amp; MyType3 MyIntersectionType = MyType1 \u0026amp; MyType2 MyType3 MyStruct = has myField: Integer has myField2: String // Values of type MyStruct are limited to those which have // both `myField` and `myField2` fields   intersect\u0026lt;MyType1, MyType2\u0026gt; myVariable; using MyStruct = intersect\u0026lt;struct { int x; }, struct { int y; }\u0026gt; // Values of type MyStruct are limited to those which have // both `myField` and `myField2` fields (struct { int x, y; })   type MyIntersectionType = MyType1 \u0026amp; MyType2 type MyStruct = { x :: Integer } \u0026amp; { y :: Bool } -- Values of type MyStruct are limited to those which have -- both `myField` and `myField2` fields (MyStruct { x :: Integer, y :: Bool })   In our magical language, type-level expressions could contain runtime values. This could be both constructed types and subtractive types that would filter out values of types they\u0026rsquo;re intersecting with. For example, here we use \u0026ldquo;myNaturalVariable\u0026rdquo; in inline type definition:\npseudocode cpp haskell  myNaturalVariable: Integer (\u0026gt;=0) myVariableWithCondition: {1, 2, 3, myNaturalVariable} if myNaturalVariable \u0026gt; 3   auto positive = [](int x){ return x \u0026gt;= 0; }; using MyNaturalType = intersect\u0026lt;int, refine(positive)\u0026gt;; MyNaturalType myNaturalVariable; using MyTypeWithCondition = intersect\u0026lt;{1, 2, 3, myNaturalVariable}, condition(myNaturalVariable \u0026gt; 3)\u0026gt;;   type MyNaturalType = Integer \u0026amp; refine (\u0026gt;=0) myNaturalVariable :: MyNaturalType myNaturalVariable = 4 type MyTypeWithCondition = [ 1, 2, 3, myNaturalVariable ] \u0026amp; { myNaturalVariable \u0026gt; 3}   Unique to this theoretical language. Types should not only be on the same level as variables, but also they should act as functions, collections, and as true predicates. All these concepts can be unified with one syntax for a concept of \u0026ldquo;type filter\u0026rdquo;.\nIn the examples for C++ and Haskell, I use refine function/keyword, which creates a refinement type out of function - otherwise, if we write just functions, it won\u0026rsquo;t look as clear. Also, C++ doesn\u0026rsquo;t allow type annotation of any value, so I can\u0026rsquo;t apply \u0026ldquo;type filter\u0026rdquo; idea to it.\npseudocode cpp haskell  3: Int print (Int 3) \u0026#34;123\u0026#34;: Boolean // error 4: \u0026gt;0 // partially applied \u0026#34;greater than zero\u0026#34; function  // acts as a type (=2) 2 = 2 : (=2) // hellish mashup 1: (x-\u0026gt;1) // lambda as set/type  myList = [1, 2, 3, 4, 5] // with this syntax, there are some cool ways to say `map (1+) myList`: print (x:myList -\u0026gt; x+1) // [2, 3, 4. 5, 6] print {x:myList + 1} // [2, 3, 4. 5, 6]   auto positive = [](int x){ return x \u0026gt; 0; }; refine(positive) x; // partially applied \u0026#34;greater than zero\u0026#34; function  // acts as a type    x :: Integer \u0026amp; refine (\u0026gt;0) \u0026#34;123\u0026#34; :: Boolean -- error 4 :: refine (\u0026gt;0) -- partially applied greater than zero function -- acts as a type   Dependent Types With Runtime Values This is not possible anywhere now (is it?), but I\u0026rsquo;m sure after 30 more years of research, we\u0026rsquo;ll be able to do this in some experimental Haskell extension or language. Runtime values can be used in static types and erased after compilation, leaving dynamic checks only on entry points. Here is a simple example of what this could look like:\npseudocode cpp haskell  Dog = has isAwake: Boolean bark() : String // type intersection takes place  if isAwake // String \u0026amp; (if not isAwake)  = \u0026#34;woof\u0026#34; dog: Dog dog.isAwake \u0026lt;- read Boolean print dog.bark() // error: can\u0026#39;t apply `dog.bark`,  // `dog.isAwake` could be false if dog.isAwake // theoretical \u0026#34;if\u0026#34; intersects types with  // information from the condition  print dog.bark() // woof   struct Dog { bool isAwake; auto bark() -\u0026gt; intersect\u0026lt;string, condition(isAwake)\u0026gt; { return \u0026#34;woof\u0026#34;; } }; ... Dog dog; std::cin \u0026gt;\u0026gt; dog.isAwake; std::cout \u0026lt;\u0026lt; dog.bark(); // error: can\u0026#39;t apply `Dog::bark`,  // `dog.isAwake` could be false if auto (dog.isAwake) { // theoretical \u0026#34;if auto\u0026#34; intersects types with  // information from the condition  // (of course, I had to invent another use for auto)  std::cout \u0026lt;\u0026lt; dog.bark(); // woof }   data Dog = Dog { isAwake :: Boolean } bark :: { this :: Dog } -\u0026gt; String \u0026amp; if isAwake this bark this = \u0026#34;woof\u0026#34; main :: IO () main = do isDogAwake \u0026lt;- getLine let dog = Dog { isAwake = (read isDogAwake :: Boolean) } print $ bark dog -- error: can\u0026#39;t apply `bark`,  -- `dog.isAwake` could be false if\u0026#39; isAwake dog then -- theoretical \u0026#34;if\u0026#39;\u0026#34; intersects types  -- with information from the condition print $ bark dog -- woof   My dog actually can bark while sleeping, but in the example above, you won\u0026rsquo;t be able to call bark function without guaranteeing that isAwake is false.\nHere is one more example of the same concept:\npseudocode cpp haskell  Dog = has maxFood = 10 food: \u0026gt;= 0 \u0026lt;= maxFood isHungry = food != maxFood eat newFood : where newFood + food \u0026lt; maxFood if isHungry = food \u0026lt;- food + newFood dog: Dog dog.food \u0026lt;- 2 dog.eat (read Integer) // error: argument newFood doesn\u0026#39;t satisfy `newFood + food \u0026lt; maxFood` and `isHungry` read Integer : clamp 0 5 : dog.eat   struct Dog { int maxFood = 10; intersect\u0026lt;int, refine(greaterEqualThan(0)), refine(lessEqualThan(maxFood)) \u0026gt; food; bool isHungry() { return food != maxFood; } auto eat(int newFood) -\u0026gt; intersect\u0026lt;void, condition(newFood + food \u0026lt; maxFood), condition(isHungry()) \u0026gt; { food += newFood; } }; ... Dog dog; dog.food = 2; int newFood; std::cin \u0026gt;\u0026gt; newFood; dog.eat(newFood); // error: argument newFood doesn\u0026#39;t satisfy  //`newFood + food \u0026lt; maxFood` and `isHungry`  dog.eat(clamp(0, newFood, 5)); // no error   type Dog = { maxFood :: Int, food :: Int \u0026amp; refine (\u0026lt;=maxFood) } isHungry dog = food dog != maxFood eat :: { this :: Dog } -\u0026gt; { newFood :: Int } -\u0026gt; Dog \u0026amp; if isHungry \u0026amp; if food this + newFood \u0026lt; maxFood this = ... ... main = do foodToEatInput \u0026lt;- getLine let foodToEat = read foodToEatInput :: Int let dog = Dog { food = 2, maxFood = 10 } print $ eat dog footToEat -- error: argument newFood doesn\u0026#39;t satisfy: -- - food this + newFodd \u0026lt; maxFood this  -- - isHungry let foodToEatLimited = clamp (0, 5) newFood print $ eat dog footToEat -- no error   Laws It can be implementation-dependent whether the value is actually stored in memory, or is it inferred at compile time like an evidence and discarded immediately. Perhaps things like implication and abstract value could be cleaner than a typed variable.\npseudocode cpp haskell  Dog = has ... food \u0026lt; maxFood =\u0026gt; isHungry ... dog: Dog dog.food \u0026lt;- read (0 \u0026lt;= _ \u0026lt;= 10) dog.eat 1 // error: couldn\u0026#39;t satisfy `isHungry` (`food \u0026lt;= maxFood`)   class Dog { ... implication(food \u0026lt; maxFood, isHungry); ... }; Dog dog; std::cin \u0026gt;\u0026gt; dog.food; dog.eat(1); // error: couldn\u0026#39;t satisfy `isHungry` (`food \u0026lt;= maxFood`)   type Dog = { maxFood :: Int, food :: Int \u0026amp; refine (\u0026lt;=maxFood) } isHungry dog = food \u0026lt; maxFood eat :: { isHungry dog } =\u0026gt; { dog :: Dog } -\u0026gt; Dog\nmain = do foodInput \u0026lt;- getLine let dog = Dog { food = (read foodInput :: Int), maxFood = 10 } print $ eat dog 1 \u0026ndash; error: couldn\u0026rsquo;t satisfy isHungry (food \u0026lt;= maxFood)\n There is enough information for isHungry flag would be completely erased on runtime, even though no values are known at compile time: all checks are performed outside on input, conversions, and manual tests!\nBy the way, this actually resembles logic programming on Prolog and similar systems.\nComplex Relations Expressed With Type System Static typing in popular languages is very good for letting you know about typos, misplaced arguments, and other minor mess-ups. But it is usually too concrete to give a programmer the ability to express higher concepts and rule out possibilities of behavior-related bugs. While proposed ideas obviously can\u0026rsquo;t solve all of them, it\u0026rsquo;s certainly useful to let users describe more details of the system using the tools in the language.\nCase Study: Game UI Bugs Let\u0026rsquo;s suppose that in some game, the player is suggested to select one or more goods at the same time and click upgrade button to buy selected goods for his gold. There are many kinds of bugs for UI to protect from, such as\n buying 0 goods spending all gold in some other window and then buying something in this window because it wasn\u0026rsquo;t updated somehow buying things twice at the same time buying things for less gold than required  These errors need to be explicitly warned in UI - that means that every bug has to be mentally (and sometimes physically) procesed multiple times. It would be good to remove this burden from an UI implementor. He would be warned of each bug and he will be forced to handle each case that is described right in the type system.\npseudocode cpp haskell  GoodInShop = has item: InventoryItem cost: Cost Shop = has ... player: Player buy goods = ... where goods: [GoodInShop] this.player.gold \u0026gt;= fold (+) (x:goods -\u0026gt; x.cost) not goods.isEmpty   struct GoodInShop { InventoryItem item; Cost cost; }; class Shop { ... using GoodsToBuy = intersect( const std::vector\u0026lt;GoodInShop\u0026gt;\u0026amp;, // wrong  refine([](const std::vector\u0026lt;GoodInShop\u0026gt;\u0026amp; goods){ return !goods.empty(); }), refine([this](const std::vector\u0026lt;GoodInShop\u0026gt;\u0026amp; goods){ return player-\u0026gt;gold() \u0026gt;= std::ranges::accumulate(goods, 0 [](const auto\u0026amp; x, const auto\u0026amp;y){ return x.cost + y.cost;} ); }) ); void buy(GoodsToBuy goods); };   data GoodInShop = GoodInShop { inventoryItem :: InventoryItem, cost :: Cost } type BuyOrder = (Player, [GoodInShop]) \u0026amp; refine ((!=[]) . snd) \u0026amp; refine (\\(player, goods) -\u0026gt; foldl (+) 0 x \u0026gt; gold player) buy :: PlayerId -\u0026gt; GoodsToBuy -\u0026gt; Shop ()   How a game designer could try to use it at first in UI layer:\npseudocode cpp haskell  ShopWindowWidget.buyButton.onClick = do goodToBuy: this.goodsBox.children GoodInShop goodToBuy.Selected = true this.shop.buy {goodToBuy} // error:   ... this-\u0026gt;buyButton-\u0026gt;onClick([this](){ std::vector\u0026lt;GoodInShop\u0026gt; goodsToBuy; for (auto\u0026amp; child: this-\u0026gt;goodsBox) { if (auto goodToBuy = Cast\u0026lt;GoodInShop\u0026gt;(child)) { if (goodToBuy.Selected) goodsToBuy.push_back(goodToBuy.good) } } this-\u0026gt;shop-\u0026gt;buy(goodsToBuy); // error:  }); ...   ... button \u0026lt;- makeButton \u0026#34;BuyButton\u0026#34; $ do goodsToBuy \u0026lt;- getSelectedGoods buy shop goodsToBuy // error: ... getSelectedGoods :: GUI [GoodInShop] getSelectedGoods = do ...   Type system immediately will stop him, noting that goodsToBuy can be empty and that he didn\u0026rsquo;t handle the case when there is not enough gold. User can then probably handle these cases like that\npseudocode cpp haskell  ShopWindowWidget.buyButton.onClick = do goodToBuy: this.goodsBox.children GoodInShop goodToBuy.Selected = true if isEmpty goodToBuy this.displayNoGoodsSelected() else if this.player.gold \u0026lt; fold (+) (x:goods -\u0026gt; x.cost) this.displayNotEnoughGold() else this.shop.buy {goodToBuy}   ... this-\u0026gt;buyButton-\u0026gt;onClick([this](){ std::vector\u0026lt;GoodInShop\u0026gt; goodsToBuy; for (auto\u0026amp; child: this-\u0026gt;goodsBox) { if auto (auto goodToBuy = Cast\u0026lt;GoodInShop\u0026gt;(child)) { if auto (goodToBuy.Selected) goodsToBuy.push_back(goodToBuy.good) } } if auto (goodsToBuy.empty()) displayNoGoodsSelected(); else if auto (player-\u0026gt;gold() \u0026gt;= std::ranges::accumulate(goods, Goods::cost)) displayNotEnoughGold(); else this-\u0026gt;shop-\u0026gt;buy(goodsToBuy); }); ...   ... button \u0026lt;- makeButton \u0026#34;BuyButton\u0026#34; $ do goodsToBuy \u0026lt;- getSelectedGoods buy shop goodsToBuy ... getSelectedGoods :: GUI [GoodInShop] getSelectedGoods = do ...   Now, type system quickly ensures that the player will never have less gold than needed on calling buy, and it won\u0026rsquo;t allow passing an empty array or any other incorrect data. It would make sense to name give these types/rules simple names and reuse them across the project.\nAsking The Type System No one would want to rewrite parts of conditions like in the previous example. You would either alias each of intersection operands and test separately, or check for generic error. Maybe there could be a special tool that would return true if an argument can be applied by function, kind of like SFINAE in C++:\npseudocode cpp haskell  if fits glDrawElementsInstanced mode count _ indexBuffer _ ... else fail \u0026#34;incorrect buffer size specified\u0026#34;   if constexpr (fits\u0026lt;glDrawElementsInstanced, mode, count, _, indexBuffer, _\u0026gt;()) ... else return std::unexpected(\u0026#34;incorrect buffer size specified\u0026#34;);   if fits glDrawElementsInstanced mode count _ indexBuffer _ then ... else fail \u0026#34;incorrect buffer size specified\u0026#34;   Perhaps we could wrap it into a language\u0026rsquo;s error management systems/patterns somehow (I suggest to read all examples\npseudocode cpp haskell  try print (read MyStructure) catch error: TypeError print e.message   try constexpr { // haha  ... } catch (std::type_error e) { ... }   parseUser :: String -\u0026gt; String -\u0026gt; TypeCheck User parseUser name description = parsedName \u0026lt;- parseName name parsedDesc \u0026lt;- parseDesc desc return $ User name desc ... checkType (parseUser \u0026#34;Jane Doe\u0026#34; \u0026#34;123\u0026#34;)\u0026#34;   Synergizing Types To provide easiest experience when mixing runtime and compile-time computations, we could not only erase the boundary between type-level entities and value-level entities, but also erase the boundary between types and collections.\nIn the example below, types/functions could have other operations bound to them, allowing them to be used in listing all values from the time, like in collection. Certain things, like Integers could have these operations defined so that their behaviour is obvious.\npseudocode cpp haskell  for i: (\u0026gt;0) // error: no end condition  print i for i: (\u0026lt;10) // error: no start condition  print i for 0 \u0026lt; i \u0026lt; 10 print i // 12345678910   for (auto i: moreThan(0)) // error: no end condition (or `begin`)  std::cout \u0026lt;\u0026lt; i; for (auto i: lessThan(10)) // error: no start condition (or `end`)  std::cout \u0026lt;\u0026lt; i; for (auto i: values\u0026lt;intersect\u0026lt;lessThan(0), moreThan(10)\u0026gt;\u0026gt;()) std::cout \u0026lt;\u0026lt; i; // 12345678910   map print (\u0026gt;0) -- endless print map print ((\u0026gt;0) \u0026amp; (\u0026lt;10)) -- 12345678910   So, \u0026ldquo;more-than\u0026rdquo; type would provide a way to get the beginning of the collection, \u0026ldquo;less-than\u0026rdquo; specifies an ending, and integer would tell the compiler to increment value to get the next value. All three combined allow you to go through each value.\nCase Study: Calculated Values as Evidence Let\u0026rsquo;s review something less \u0026ldquo;arithmetic\u0026rdquo; in the context of this idea.\npseudocode cpp haskell  Creature = has ... NearEnemy c: Creature = c.faction != this.faction distance c.position this.position \u0026lt; this.attackRange attack target: this.NearEnemy = target.applyDamage this.getDamage attackClosestEnemy() = do nearEnemies = world.creatures this.NearEnemy attack (world.random.pick nearEnemies)   class Creature { ... auto NearEnemy\u0026lt;const Creature\u0026amp; c\u0026gt; = intersect\u0026lt;condition(c.faction != faction), condition(distance(c.position, position) \u0026lt; attackRange)\u0026gt;; void attack(const NearEnemy\u0026amp; target) { target.applyDamage(getDamage()); } void attackClosestEnemy() { auto nearEnemies = values(intersect\u0026lt;world-\u0026gt;creatures, NearEnemy\u0026gt;); attack(world.random.pick(nearEnemies)); } };   nearEnemy :: Creature -\u0026gt; Creature -\u0026gt; Boolean nearEnemy c other = faction c != faction other \u0026amp;\u0026amp; distance (position c) (position other) \u0026lt; attackRange c attack :: Creature -\u0026gt; NearEnemy -\u0026gt; GameState () attack this enemy = applyDamage enemy (damage this) attackClosestEnemy :: Creature -\u0026gt; GameState () attackClosestEnemy this = creatures \u0026lt;- getCreatures let nearEnemies = creatures \u0026amp; nearEnemy randomCreature \u0026lt;- randomPick nearEnemies attack this randomCreature   All the work happens in nearEnemies - it goes through all creatures in the world and filters only those from different faction and in near attack range. attack then takes a value that is definitely a NearEnemy. I think this could be a great improvement in readability, coding speed, and safety.\nConclusion Of course, by \u0026ldquo;simpler types\u0026rdquo; I mean that they shouldn\u0026rsquo;t be simple in terms of theory behind them. Supporting things above with at compile type and with type erasure could take years of research and implementation. But it will be simpler from user perspective: there should less rules and limitations of what a user can write. For example, by C++17 standard, you are not allowed to capture structured bindings into lambdas. This is a pointless limitation that was fixed in the next standard. Not allowing runtime values in types is similar too. Whatever you write, it should work as expected, like a blackboard.\n","permalink":"https://kvachev.com/blog/posts/we-need-simpler-types/","summary":"\u003cp\u003eDependent types, refinement types, gradual types, rank-n polymorphism, etc, \u0026ndash; we are moving in the right direction\u003c/p\u003e","title":"We Need Simpler Types"},{"content":"Simultaneous turns are useful for providing balanced parallel turn-based gameplay, but they will also provide you with a lot of design challenges\nParallel Multiplayer  Showing a black screen at the time of another player\u0026rsquo;s turn is really boring: it breaks the flow, multiplies game session times, and sometimes even makes players angry at each other for taking turns too slowly. Unless it\u0026rsquo;s a single player game, you might want to resolve this somehow, and it\u0026rsquo;s better to think on it as early as possible. Let\u0026rsquo;s have an overview of alternatives to sequential turns.\nReal-Time Elements Some games resort to adding real-time elements: all players make moves at the same time, but you have to make important conflicting actions really fast at the beginning of your turn, otherwise your opponent will do this first and you might lose significant advantage. This opposes the cold and strategic nature of turn-based games, also it depends on internet speed, animation speed and delays after actions that your designers have unfortunately decided to set up.\nNotable examples: Civilization 6, modded HoMM 5\nThere is a lot of fun in turn-based games when you add multiplayer in it, but if you want well-balanced competitive play, it\u0026rsquo;s good to consider less straightforward options too:\nResolution Phase Other games explicitly define a resolution phase: after every player has completed their turns and submitted them, the game will calculate the state for the next turn. Games with resolution phase may vary from setting AI schemes for every unit to setting movement trajectories and projectile paths.\nNotable examples: Dominions 5, Circle Empires Tactics, Colossal Citadels\n Screenshot from Atlas Reactor - it based on exact planning of all actions for every unit\n(In)complete Information The third option is what most board games use: they still offer parallel gameplay without giving players the ability to make actions at other players' turns. This gameplay is represented by analyzing other players' actions: you can see everything (or at least something) that they do, making you plan changes to your strategy until it\u0026rsquo;s your turn.\nWith small enough turns, you possibly can eliminate waiting, as some players might think ahead and make the turns immediately after their turns have started\nNotable examples: Chess, Hearthstone\nBut, of course, this category is not describing purely simultaneous turn games.\nLong Term Planning Some games with sequential turns also allow making queues of actions during player (or non-player turns). For example, place a very long movement order that will span through multiple turns, push 5 productions into a city\u0026rsquo;s queue, and so on.\nNotable examples: every 4X game\nAlternating Phases This is a weird unexplored idea. Imagine if some parts of the game did not depend on each other at every moment of time: that would allow different players to do different things at the same time. For example, one of the players is currently in the building stage, and the other one is in the exploration stage. Both click END TURN, and their roles invert!\nI don\u0026rsquo;t remember any examples of a similar turn structure. Do you?\nBlends It\u0026rsquo;s possible to mix all of these above. You can make some parts of the game fully sequential, while, for example, overworld gameplay happens simultaneously. This is what Humankind does with battles on a 4X map: when units overlap, battles with sequential turns start on a smaller map, but you can do everything else in your empire while waiting for your opponent\u0026rsquo;s next action.\n Notable examples: Paradox games, while being real-time, feel turn-based because players can agree to make a pause to resolve their decisions.\nDesigning the Resolution Phase This is what I\u0026rsquo;ll go into detail in this post. This type of gameplay heavily relies on short-timed planning and predicting what your opponent will do.\nPredictive Play Fully simultaneous turn-based games are more prediction-oriented and \u0026ldquo;risky\u0026rdquo; in their nature than \u0026ldquo;puzzling\u0026rdquo; and \u0026ldquo;tactical\u0026rdquo;. You can draw parallels with fighting games and other kinds of rock paper scissors. While most tactical games require some sort of prediction of the opponent\u0026rsquo;s strategy, in games with planning, you have to make micro-predictions that may win or fail immediately.\nConflicting Actions The main difficulty of working with simultaneous turns is that simultaneous player actions can\u0026rsquo;t depend on each other. You would need to implement some resolution mechanic for each conflicting action. For example, an abstract Troll can throw someone far away. What if two trolls throw each other at the same time? Moreover, what if the enemy healer casts AOE heal on the area where the thrown enemy was residing? Such cases need explicit attention in gameplay mechanics. There are multiple ways to solve it, for example:\n Implicit order and initiative: all actions are sorted using some special metric, and in case of conflicting actions that can depend on each other, this metric can resolve this. Moreover, it can be turned into an explicit stat or a resource. Many TTRPGS have initiative rolls that depend on character stats. Initiative only for conflicting actions: conflicts are not critical in most cases (two trolls just throw each other and it\u0026rsquo;s fine), but for some special cases an initiative mechanic would be used. Randomness  The impact of simultaneous action conflict may be significant in games with low amount units and fewer steps in the resolution phase. With a big enough amount of steps in the phase, gameplay moves towards being continuous, eventually becoming a real-time game.\nProgramming Many turn-based games offer some way to set things up for the following turns. In Dominions 5, you can place your formations right on the theoretical battlefield, you can set behavior for them. In the actual battle, you will then see how well your placement works, how easy it was to get to your archers, and so on.\n More extreme examples allow exact planning of micro actions, such as shooting slow-moving projectiles so that enemy would go into it. Circle Empires Tactics offers a lot of that tight prediction experience, capturing the essence of prediction-based strategy.\nI, too, implemented movement paths in my project - one of the factions will have much fewer units, but each one can be controlled individually. The implementation is not finished yet (both visually and mechanically), but here is how it looks so far:\nYour browser does not support the video tag.  Estimating Odds This can be applied not only to all kinds of games with abilities. First of all, you can graphically show predicted outcomes of player actions. For example, when a player considers throwing a fireball, it would be convenient to immediately see how much damage they would do. Take a look at health bars (red segments of triangular borders around creatures). I described tricks with healthbars in this old tweet. Here is also an idea on how movements and battles could be displayed:\nYour browser does not support the video tag.  Moreover, it\u0026rsquo;s possible to make a complete prediction of the next turn state in case of simultaneous turns - this might be useful if the design is based around an AI taking steps both for the player and the neutral/enemy units.\nYour browser does not support the video tag.  To do any kind of prediction visualization, actions need to be deterministic. It would be difficult to show prediction of attack damage if there are critical strikes possible, or to reliably draw movement trajectories, if there is any output randomness at all. For example, you can replace randomness with different mechanics: like, instead of a 10% crit chance, do a guaranteed crit every 10th turn.\nPlanning From Possible Enemy Actions Of course, the player\u0026rsquo;s predictions are more important than automatic ones! That\u0026rsquo;s why you can give players another tool to make predictions more convenient: allow planning by playing enemy units too! This is what, for example, Frozen Synapse 2 does.\n There is also an important decision: will you show the enemy\u0026rsquo;s exact action prediction for the next turn, or will you make the player think on the range of things that possibly could happen, like in multiplayer? Both have interesting implications: Into The Breach and Slay The Spire made some really fun things with telegraphing enemy actions. But this is obviously not possible in a multiplayer game - these have to stick with the second option.\nVisual Feedback A very big amount of polish in strategy games comes from actually observing your actions: when you throw a fireball, an explosion comes from the tip of your cursor. While this is not the primary kind of fun strategy gamers aim for, it is crucial for the game feel. Fully simultaneous turns struggle with this, as most actions can be played only in the resolution phase. Make sure to add enough effects on placing orders in planning-style games. For example,\n theme-specific animations: spell rituals, or, perhaps, warriors clash their swords and shields when you place a movement order, and their leader surely should do this gesture (from Warcraft 3 intro)  Your browser does not support the video tag.   trajectory visualizing lines should appear, with juicy animations epic sound, of course screenshake!  Moreover, it\u0026rsquo;s actually possible to play animations for some types of player actions. Placing buffs, non-killing damage, summoning demons: all of that could be played right away if your mechanics allow it!\nConclusion Implementing parallel gameplay into a turn-based game is a broad topic with a big space for creativity. There are a lot of ideas to come up with: don\u0026rsquo;t be lazy and playtest them immediately.\n","permalink":"https://kvachev.com/blog/posts/simultaneous-turns/","summary":"\u003cp\u003eSimultaneous turns are useful for providing balanced parallel turn-based gameplay, but they will also provide you with a lot of design challenges\u003c/p\u003e","title":"Simultaneous Turns"},{"content":"Grids are great for tactical gameplay of turn-based games because they allow discrete movement steps. That means that you can bind positioning to other resources such as movement points, action points, food, etc. Grids divide the infinite variety of movement options into a few specific ones, which can be considered separately by the player\u0026rsquo;s tactical mind. The most popular grid types are hexes and squares. But what about triangles?\nYour browser does not support the video tag.  Types of Grids: Comparison We are perfectly familiar with square and hex grids, as most turn-based games use one of them. Both have upsides and downsides. I will go through each of these and include the triangle grid in comparison.\n Visuals Square grids will contribute to visuals for non-natural environments, such as towns, dungeons, streets, and building interiors.\nHex grids look nice with natural environments instead, improving the realism of curvy things, such as islands, mountains, small roads, etc.\nIn the case with looks, triangle grids lie in between: like squares, they allow straight lines and walls without half-tiles, and like hexes, they allow more curvy environments. In fact, triangle grids contain both in itself! You can even have rhombus (huge) and hex (colossal) creatures on top of the triangle grid, like this:\n On top of that, it has a bonus: like the square grid, it can contain bigger and smaller grids in itself.\nThe only visual downside before the square grid is that it can\u0026rsquo;t express rectangle buildings. In this case, the same cheat from the hex grid can be used: use half tiles. A blocking object (wall) goes through half of the tile and the tile is blocked completely.\n There are also two special cases that make triangles shine. The first is line formations. When the second row of spearmen/riflemen stays between the first, like on the picture above, they can attack enemy formation too without a friend obstructing the view.\nSo it\u0026rsquo;s possible to directly represent lines of soldiers on triangular grids; formations will also have the ability to rotate in 6 directions. But this point applies to hex grids too, it\u0026rsquo;s just that the second row will be further away from enemies, and with triangles, enemies in front of the formations are diagonally-adjacent to the second row. I\u0026rsquo;ll tell you more about diagonals and diagonal distances in a minute.\n Another thing is citadels/bastions. These angles allow more convenient defenses, and fortifications were often built this way throughout history. In Colossal Citadels I made walls and houses follow the triangular grid and I love how these procedurally-generated castles turned out:\n Directions and Adjacent Tiles The number of tactical options (movements, attacks, ranged straight-line attacks) depends on the type of grid. It also depends on whether or not you allow diagonal directions. Let\u0026rsquo;s count how many non-diagonal directions each grid type allows:\n  Square grid: 4 adjacent tiles, 4 directions Hex grid: 6 adjacent tiles, 6 directions Triangle grid: 3 adjacent tiles, 6 directions  Restricting the number of options would make sense in a tight puzzle-like tactics game, and in bigger strategy games you might want to increase the variety of options to depend less on micro tactics on movement.\nDirections And Adjacent Tiles: Diagonals Some games increase these numbers by allowing diagonal tiles and directions. This is where triangle grids overcome other variants!\n  Square grid: 8 adjacent tiles, 8 directions Hex grid: 6 adjacent tiles, 6 directions Triangle grid: 12 adjacent tiles, 12 directions  So, if you want to have more options, triangle grids with diagonals are a good choice. Ranged \u0026ldquo;line\u0026rdquo; attacks also look slightly better because they\u0026rsquo;re not alternating as with the hex grids; be sure to highlight the lines in 6 straight diagonals, or it will look not so good.\nDistances   Hex grids are very good at estimating the closest path - you can naturally see the closest point. Square grids without diagonals are not so convenient, but distances are always easy to calculate. Triangle grids without diagonals are fine, but there is an issue when you have an opposing triangle: it takes 3 steps to move to it. This might look weird and unnatural. We can fix this by introducing diagonals: allow jumping to the opposing triangle at the cost of 2 instead of three. Then, triangular grid becomes convenient to use and more realistic:   You can find calculating functions for all distances (and explanations) in the end of this article. By the way, I believe I was the first to mention this and the next kind of triangle diagonal distances in the internet here - it links to another cool article by BorisTheBrave. But these grids are simple stuff in my opinion, and most possibly, board game developers who explored triangle grids already have considered it long ago.\nSo, this way of calculating distance is quite fine for movements, but for less edgy shapes (for example, buildings), you might want to have something even simpler: full diagonal distances. Treat all tiles that touch the current triangle with one of the vertices as a distance of 1.\n Unfortunately, this approach is not a panacea: it\u0026rsquo;s not that beautiful for movement, because a moving unit can cheat a little bit and cover up to two times more tiles than in previous distance measures! Can you figure out how? But this type of distance is very good for ranged attacks and zones! So, I would suggest using either the previous formula, or both: full diagonals for ranges and diagonal shortcut for movements.\nHeightmap Terrains This is not a gameplay point, but it\u0026rsquo;s still worth mentioning. There is a way of drawing terrain meshes with triangles instead of quads. This way can save some percentage of triangle count and fixes some other issues automatically. If terrain tiles are tied to gameplay, this is going to look interesting. I\u0026rsquo;ve not seen a triangular grid voxel minecraft-like game yet!\n How To Use Triangular Grid Red Blob Games\u0026rsquo;s article provides a lot of thoughts on representations of triangle grid, but I\u0026rsquo;ll just use the best one and supply it with a lot of common useful operations on it.\nCoordinate Representation The most convenient option is to represent it as square grid coordinates PLUS a number that means half-square - 0 or 1.\nstruct Pos { int x, y, s; }; Conversions Conversions between index, coordinates, and 2D world coordinates are going to be the most common operations.\nIndex \u0026lt;-\u0026gt; Coordinates int toIndex(const Pos\u0026amp; pos, int gridWidth) { return pos.x * 2 + pos.y * gridWidth * 2 + pos.s; } Pos fromIndex(int i, int gridWidth) { return Pos{(i / 2) % gridWidth, (i / 2) / gridWidth, i % 2}; } World \u0026lt;-\u0026gt; Coordinates struct Vec2 { float x, y; }; We will need some constants for representing tile size in world space. I use these:\nnamespace TriangleConstants { const float Height = 150.f; const float Side = 173.20508075689f; } Vec2 gridToWorld( const Pos\u0026amp; pos, float worldspaceTriangleSide, float worldspaceTriangleHeight) { return Vec2{ pos.x * worldspaceTriangleSide + pos.y * worldspaceTriangleSide / 2.f, pos.y * worldspaceTriangleHeight }; } Pos worldToGrid(const Vec2\u0026amp; pos) { float y = std::get\u0026lt;1\u0026gt;(pos) / TriangleConstants::Height; float x = std::get\u0026lt;0\u0026gt;(pos) / TriangleConstants::Side - y / 2.f; bool s = (x - floorf(x) + y - floorf(y)) \u0026gt; 1.f; return Pos{int(x), int(y), int(s)}; } Trianglular Grid \u0026lt;-\u0026gt; Square Grid It\u0026rsquo;s just as simple as taking x and y components and adding or removing third coordinate from them.\nTriangle Tile Distance To calculate simple tile distance you can use Manhattan distance with addition of third component difference.\nint distance(const Pos\u0026amp; a, const Pos\u0026amp; b) { auto dx = a.x - b.x; auto dy = a.y - b.y; auto ds = a.s - b.s; return abs(dx) + abs(dy) + abs(dx + dy + ds); } The logic behind this formula is that first you need to convert your coordinates to intermediate representation (adx, adx, adz), that reflects distances from initial point on three axes, each one parallel to one side of a triangle. Since it is just a taxicab distance, you need to just sum three components up.\nConvenient distance functions are a bit more complex:\nDiagonal Triangle Tile Distance (Shortcuts) To allow movement through diagonal, you have to subtract the minimum of three distance components from the previous formula. Why is that and how did I find this? That information is lost\u0026hellip; Probably, I just noticed it from staring at triangular grid for too long.\nint triangleDistanceDiagonal(const TilePosition\u0026amp; a, const TilePosition\u0026amp; b) { auto dx = a.x - b.x; auto dy = a.y - b.y; auto ds = a.s - b.s; auto adx = abs(dx); auto ady = abs(dy); auto adz = abs(dx + dy + ds); auto m = std::min({adx, ady, adz}); return adx + ady + adz - m; } Diagonal Triangle Tile Distance (Full) This is much simpler. To treat all diagonal tiles as distance one, you have to find maximum of all three components instead:\nint triangleDistanceFullDiagonal(const TilePosition\u0026amp; a, const TilePosition\u0026amp; b) { auto dx = a.x - b.x; auto dy = a.y - b.y; auto ds = a.s - b.s; auto adx = abs(dx); auto ady = abs(dy); auto adz = abs(dx + dy + ds); return std::max({adx, ady, adz}); } Source Code All these functions plus some lesser ones, for example, calculating adjacent coordinate with or without diagonals, are included in my tiny header library. Feel free to use it, it\u0026rsquo;s published under CC0.\nYour browser does not support the video tag.  Conclusion Triangular grids are a fantastic option too. As far as I know, there are no released games that make use of triangle grids yet. Maybe my project (from the screenshots above) will be the first? There are some board games - someone even tried to play Go on triangular grids.\nHowever, the design of my game doesn\u0026rsquo;t need precise movement controls. You still play with grids with abilities and town-building, but the positioning of creatures is automatic. So, the space for classic turn-based tactics on triangle grids will be still open.\nThere are also other bizarre and irregular grid types. I can see some interesting gameplay ideas coming out from these, e.g. buildings can only go on big tiles, or smaller tiles are for \u0026ldquo;upgrades\u0026rdquo; that apply to big tiles, and so on.\n ","permalink":"https://kvachev.com/blog/posts/triangular-grid/","summary":"\u003cp\u003eGrids are great for tactical gameplay of turn-based games because they allow discrete movement steps. That means that you can bind positioning to other resources such as movement points, action points, food, etc. Grids divide the infinite variety of movement options into a few specific ones, which can be considered separately by the player\u0026rsquo;s tactical mind. The most popular grid types are hexes and squares. But what about triangles?\u003c/p\u003e","title":"Triangle Grids"},{"content":"This fog looks almost like volumetrics but takes almost no time to render\nYour browser does not support the video tag.  Intro I\u0026rsquo;ve been requested many times since I posted this video on social networks to write an article about how this fog works. Ok, this will be a tutorial with some details about every part of implementation, so that you can make your own fog with similar steps. Coefficients will have to be different depending on your world size, slopes, camera heights and angles, so simply copying this implementation won\u0026rsquo;t work.\n Fog brings a lot of atmosphere into photos, 3d environments, games, etc. Fancy-looking fog implementations are still an open issue:\n  volumetrics look insanely good and flexible but take ages to render\n  atmospheric fog is useful only for decorating far landscapes, you can\u0026rsquo;t have different fog heights at the same time\n  And this solution - I would call it \u0026ldquo;Fog Mesh\u0026rdquo; - is not perfect too, but it would work very well for top-down games: you can get beautiful fading, all kinds of animations, and have it rendered with almost zero cost.\nThis approach is useful both for implementing fog of war for strategy games and for just decoration purposes. Unfortunately, it won\u0026rsquo;t fit first-person games (unless your character is looking down from a helicopter, for example) - it will have some visual artifacts when you\u0026rsquo;re looking from inside the fog! Yet, I hope to see more usages of this for top-down games.\nThe Composition  The fog mesh implementation can be broken down into:\n heightmap mesh that covers your terrain gaussian blur on heightmap (in mesh or in material, depending on what you need from the fog) depth fade \u0026amp; translucency in mesh material world-aligned texture (unless you want a flat-colored fog) in mesh material change of opacity depending on the distance to the camera in mesh material  So, as you see, nothing fancy, just a careful combination of parameters, mined out using a lot of iteration - you will definitely need to tweak the parameters for your terrain size, height, and camera angles. I\u0026rsquo;ll go through each part in detail. But first, let\u0026rsquo;s look at how to control it.\n Different fog colors can make a great contribution to environment flavor.\n Representation/Heightmap Input:\n You\u0026rsquo;ll need a heightmap of your terrain - texture/array of its height locations. If your terrain is flat, skip this step. You\u0026rsquo;ll need a texture/array of fog data - it can be either bools or floats. In Colossal Citadels, the fog of war is gradual and there can be fog/visibility with a value of 0.42, but usually in strategies with incomplete information you either have fog of war in a certain location or you don\u0026rsquo;t have it. Color, texture, etc will go to material parameters, but you can use vertex buffers of the fog mesh to pass color to the material as well. Just make sure they\u0026rsquo;re smooth enough  Intermediate representation:\nIf you don\u0026rsquo;t have to update the fog every frame, then you can just put fog vertices into the vertex buffer along with some additional data. You will still be able to smoothly blend between two fog states: just swap two fog meshes with world position offset animation in shader.\nYour browser does not support the video tag.  In case if you have a real-time game, which reveals a little part of fog of war every frame, you can make fog use data from a RenderTarget and draw to it instead. Then GPU will have to take some costs of processing visibility and blurring - that\u0026rsquo;s the tradeoff of such flexibility. In my example, fog changes only once in a while, and you don\u0026rsquo;t have to use RenderTarget to blend smoothly.\nFog Visibility Preprocessing This is the simplest step. Here is how I convert fog value to special intermediate values:\nstd::vector\u0026lt;float\u0026gt; visibilityA; std::vector\u0026lt;float\u0026gt; visibilityB; for (int y = 0; y \u0026lt; worldHeight; ++y) for (int x = 0; x \u0026lt; worldWidth; ++x) { int i = tileCoordsToFogMeshIndex(x, y); auto i1 = fogMeshIndexToTileIndex(i); const auto\u0026amp; tile = map-\u0026gt;GetTile(i1); auto modifyAlpha = [\u0026amp;](int coord, const TileInfo\u0026amp; tile){ if (tile.visibility() \u0026gt;= 0.f) { float visibility = std::clamp(tile.visibility(), 0.f, 1.f); visibility = 1.f - visibility; visibility *= visibility; visibility = 1.f - visibility; // this part is specific to Colossal Citadels and reduced visibilites  // around the objects - areas with little amount of fog should look completely clear  int newAlpha = static_cast\u0026lt;int\u0026gt;(visibilityA[coord]) - static_cast\u0026lt;int\u0026gt;(visibility * 42.5f) - 16; visibilityA[coord] = (newAlpha \u0026lt; 0) ? 0 : newAlpha; visibilityB[coord] = visibility * 255.f; } }; modifyAlpha(i, tile1); modifyAlpha(i + 1, tile1); modifyAlpha(i + fogWidth, tile1); modifyAlpha(i + 1 + fogWidth, tile1); } Next, apply a reasonable amount of blur to these fog values:\niir_gauss_blur\u0026lt;float, 1\u0026gt;(worldWidth, worldHeight, visibilityA.data(), RenderingParameters.Other[\u0026#34;FogVisibilityBlur\u0026#34;]); iir_gauss_blur\u0026lt;float, 1\u0026gt;(worldWidth, worldHeight, visibilityB.data(), RenderingParameters.Other[\u0026#34;FogVisibilityBlur\u0026#34;]); All these magic values will have to be tweaked for your project. Here are some additional magic formulas that go right after:\nfor (auto\u0026amp; b: visibilityB) { b /= 256.f; b = -b * 210.f; } for (auto\u0026amp; a: visibilityA) { a /= 256.f; a = std::tanf((1.f - a) * 1.571f) * 3.f; } Note that if you use RenderTargets, you\u0026rsquo;ll have to put similar code to fog material instead.\nI use TexCoord buffers to feed fog values into material:\nTangents.SetNum(verticesInFog); TexCoords.SetNum(verticesInFog); for (int y = 0; y \u0026lt; worldHeight; ++y) for (int x = 0; x \u0026lt; worldWidth; ++x) { int idx = tileCoordsToFogMeshIndex(x, y); TexCoords.SetTexCoord(idx, FVector2D(visibilityB[idx], visibilityA[idx])); } Depth Fade This is the core of the fog. We already have difficult formula for FadeDistance. We connect output of DepthFade straight to opacity of the translucent material of the fog mesh.\n Camera Angles Note that on changing angles, fog becomes denser or dissappears - this might be not wanted for implementing fog of war, which needs to clearly show where the fog starts. Also, it looks weird when you move the camera and the fog \u0026ldquo;moves\u0026rdquo; too. We\u0026rsquo;ll already mostly fixed this using previous formulas, but it camera height also messes it up. Here is one more step that makes it look better on zoom in.\n Note that in Colossal Citadels map blends between isometric and almost orthographic projection by changing field of view. For most cameras, these coefficients would be insane, so tweak them!\nTexture Your browser does not support the video tag.  This is the most artistic step - you can put any texture you want - just make sure to put it on a world-aligned virtual plane, or you will observe \u0026ldquo;artifacts\u0026rdquo; on height slopes due\nVirtual Planes I made two virtual planes using shifting perlin noise texture. Because two planes have some distance between them, it looks ridiculously good, like the fog is 3-dimensional!\nYour browser does not support the video tag.  We need to draw a plane on top of material transform the texture so that it looks like a plane parallel to the ground. Luckily, unreal engine implements that already:\n Combination of Noises These two values from previous snipped need to be combined:\n This goes to Emissive Color.\nOn the snipped above I also do do blend between texture and flat color - in my opinion it looks better on very close zoom in.\nYour browser does not support the video tag.  Smooth update of fog? Yes, you can blend between two fog states, for example, when you just moved your units and revealed some new territory. There are a variety of ways of doing that:\n initially store fog position in a texture that is used as a heightmap in the shader of fog \u0026ldquo;plane\u0026rdquo;. Draw on this position directly or blend between two images. Have two meshes that gradually swap between each other  Useful Additions It\u0026rsquo;s also possible to embed shadows and godrays here after some additional work - maybe I\u0026rsquo;ll try these someday. You can also have gradual blends between different colors (depending or tile data or just with fog shader).\nIssues The biggest issue is that fog edges still can cut abruptly if you look at it from an angle. You are also going to observe this issue if the slope is too big, for example you have too high mountains.\nHere is what I mean by unwanted angles:\n It\u0026rsquo;s possible to at least partially overcome this by:\n forbidding certain camera angles. render fog mesh to stencil or depth buffer and blur edges or/and screen in postprocessing  Fresnel won\u0026rsquo;t look good unless you have an inadequate amount of vertices.\nConclusion That\u0026rsquo;s it! I hope you got an understanding on how to create a similar fog.\n","permalink":"https://kvachev.com/blog/posts/fog-for-topdown-games/","summary":"\u003cp\u003eThis fog looks almost like volumetrics but takes almost no time to render\u003c/p\u003e","title":"Fog for Top-Down Games"},{"content":"There was some unsolved issues in my old Medium article, dozens of people viewed it every day and tried to use it nevetheless, so I deleted it. Now there are no issues, and it\u0026rsquo;s possible to link and flawlessly use protobuf without restrictions\nBefore we start, I suggest you to reconsider using grpc - you can use nice built-in Unreal Engine\u0026rsquo;s automatic serialization, replication, and RPCs with USTRUCTs. Even though UPROPERTIES have blunt capabilities - nested arrays and maps are not allowed (?), you can\u0026rsquo;t have recursive structures (??), and there are no basic things such as variants and optionals (???), it will be much more efficient to use TArrays, TMaps, and FStrings directly. You will need to convert containers and strings anyway to pass them to the engine - it\u0026rsquo;s better to store and send them directly.\nBut sometimes this is not the case, and you have to use it for accessing some other services, or you need the standard library, or something else. In this case, you might stumble into an insane amount of problems, such as link conflicts, dynamic loading issues, macro redefinitions. Luckily, this is all solvable.\nJust sharing an example project won\u0026rsquo;t work because protobuf-generated files should be built with the same version of protobuf you\u0026rsquo;re linking with, and linked libraries depend on specific windows libraries, and you have to do some specific steps every time you generate proto files. One could probably automate that someday.\nInstall GRPC Correctly Link statically - it works in newer versions. Don\u0026rsquo;t ever try to link protobuf dynamically - it\u0026rsquo;s badly designed and you will get many unsolvable issues this way. My protobuf version is 3.19.4, but try the latest version at first.\nFor Windows, I used vcpkg to install this specific triplet:\n./vcpkg.exe install grpc:x64-windows-static-md Link it to your project Then you have to link grpc and all dependencies (protobuf, zlib, openssl, c-ares, and possibly some more) with your Unreal Engine project. For simplicity, I just merged all include and lib directories from vcpkg\u0026rsquo;s installed directory.\ncp installed/\u0026lt;library\u0026gt;x64-windows-static-md/lib/* ../MyProject/ThirdParty/lib Put this into MyProject.Build.cs\nPublicIncludePaths.Add(Path.Combine(ThirdPartyPath, \u0026#34;include\u0026#34;)); string LibrariesPath = Path.Combine(ThirdPartyPath, \u0026#34;lib\u0026#34;); DirectoryInfo d = new DirectoryInfo(LibrariesPath); FileInfo[] Files = d.GetFiles(\u0026#34;*.lib\u0026#34;); foreach (FileInfo file in Files) { PublicAdditionalLibraries.Add(Path.Combine(LibrariesPath, file.Name)); } Definitions.Add(string.Format( \u0026#34;WITH_GRPC_BINDING=1\u0026#34;)); Illegal Library Movements Then we\u0026rsquo;ll have to make a couple of weird steps.\nFirst, if you have libcurl (or any other library that makes use of SSL) linked to your Unreal Engine project, you will get conflicts with openssl in your new lib dir. To resolve them you can delete these from ThirdParty/lib dir:\nrm libcrypto.lib libssl.lib If you\u0026rsquo;re actually going to use SSL channels in grpc, then it\u0026rsquo;s better to make sure that openssl versions are matching (and that\u0026rsquo;s a different story), or it\u0026rsquo;s undefined behaviour.\nSecond weird step: libraries depend on these libraries from Windows distribution: crypt32.lib iphlpapi.lib userenv.lib psapi.lib ws2_32.lib. Find them on your C drive (they can be in Windows SDK, for example) and either link against them in Strategy.Build.cs or just copy them into lib directory.\nCompile the project to see if it works!\nUsage Your .proto files should contain this code:\noption optimize_for = LITE_RUNTIME;option cc_enable_arenas = true;Then you just usually compile your protos with protoc from vcpkg\u0026rsquo;s installed directory.\n\u0026#34;installed/tools/protobuf/protoc.exe\u0026#34; -I . --grpc_out=cpp --plugin=protoc-gen-grpc=\u0026#34;/full/path/to/installed/tools/grpc/grpc_cpp_plugin.exe\u0026#34; cc/MyProject/* \u0026#34;installed/tools/protobuf/protoc.exe\u0026#34; -I . --cpp_out=cpp cc/MyProject/* For every protoc invocation Then you have to edit every .cc file generated (not the headers) and add some code before first include and some code after first include.\nThis goes before the first include:\n#include \u0026#34;EnableGrpcIncludes.h\u0026#34;This goes after the last include:\n#include \u0026#34;DisableGrpcIncludes.h\u0026#34;I will give the contents of these files at the end of the article: add them to your project.\nFor every file in your project If you include any generated headers or just protobuf/grpc headers, you\u0026rsquo;ll have to wrap them with #include \u0026quot;EnableGrpcIncludes.h\u0026quot; and #include \u0026quot;DisableGrpcIncludes.h\u0026quot; too.\nEnableGrpcIncludes.h #define GRPC_USE_PROTO_LITE 1  #ifndef WORKAROUND_SYMBOL_MEMORY_BARRIER #define WORKAROUND_SYMBOL_MEMORY_BARRIER static void MemoryBarrier() {} #endif  #pragma warning (disable : 4800) // forcing value to bool true or false #pragma warning (disable : 4125) // decimal digit terminates octal escape sequence #pragma warning (disable : 4647) // behavior change __is_pod has different value in previous version #pragma warning (disable : 4668) // \u0026#39;symbol\u0026#39; is not defined as a preprocessor macro, replacing with \u0026#39;0\u0026#39; for \u0026#39;directives\u0026#39; #pragma warning (disable : 4582) // constructor is not implicitly called #pragma warning (disable : 4583) // destructor is not implicitly called #pragma warning (disable : 4946) // reinterpret_cast #pragma warning (disable : 4005) // macro redefinition #pragma warning (disable : 4005) // initializers put in library initialization area #define GOOGLE_PROTOBUF_NO_RTTI true #ifndef __ANDROID__ #include \u0026#34;Windows/AllowWindowsPlatformTypes.h\u0026#34; #endif #pragma intrinsic(_InterlockedCompareExchange64) #define InterlockedCompareExchangeAcquire64 _InterlockedCompareExchange64 #define InterlockedCompareExchangeRelease64 _InterlockedCompareExchange64 #define InterlockedCompareExchangeNoFence64 _InterlockedCompareExchange64 #define InterlockedCompareExchange64 _InterlockedCompareExchange64 DisableGrpcIncludes.h #ifndef __ANDROID__ #include \u0026#34;Windows/HideWindowsPlatformTypes.h\u0026#34;#endif (if you want, you can re-enable warnings that were disabled in the first file)\nConclusion That\u0026rsquo;s it, now it should work flawlessly: both serving and making requests. If you have any issues, message me.\nProbably some libraries from lib can be deleted too, because not everything from there is a dependency.\n","permalink":"https://kvachev.com/blog/posts/grpc-with-unreal-engine/","summary":"\u003cp\u003e\u003cem\u003eThere was some unsolved issues in my old Medium article, dozens of people viewed it every day and tried to use it nevetheless, so I deleted it. Now there are no issues, and it\u0026rsquo;s possible to link and flawlessly use protobuf without restrictions\u003c/em\u003e\u003c/p\u003e","title":"GRPC with Unreal Engine"},{"content":"Design and Implementation of Programming Language with Generalized Sets, Types, and Functions as First-Class Values Disclaimer: This is a very formal and old article about one of my old project of designing and making a language with mad, nearly esoteric, but still cool type system with composable gradual refinements. I felt like it should not be forgotten and put it into this blog; I will write some expansions of ideas described here soon. The implementation is of course unfinished and it\u0026rsquo;s interpreted instead of compiled, but still\nAbstract We present several design ideas for an experimental programming language featuring flexible and expressive type system that ensures error prevention while preserving readability, maintainability and convenience of writing code. We argue that this goal can be achieved by unifying syntactic approach to types, sets, and functions in order to make them composable and interchangeable, and by implementing possibility to use all of them as first class citizens. In this paper we give a high-level overview of the main language features along with some implementation details. We conclude with plans for future work.\nIntroduction Many modern programming languages, such as Haskell, Scala, Agda, use rich type systems for preventing defects and specifying requirements for program entities and operations on them, increasing expressiveness and usability. There are two well-known approaches to advancing type systems, that draw much attention nowadays: dependent types and refinement types. While dependent types allow types to depend on values, refinement types provide an ability to augment types with logical predicates. Dependent types typically require higher amounts of assistance by programmers. Opposing to them, type systems based on refinement types have a high degree of automation and expressiveness of verification of program code. Refinement types do not require detailed proofs as systems with dependent types do, and they allow user to conveniently construct the constraints. In many existing implementations of systems with refinement types, the refinements are orthogonal to the base types system of the language. For example, in LiquidHaskell, which is an extension of Haskell programming language, constructions with refinement types are specified in the form of special annotations and used exclusively for static validation of the source code. In refinement type annotations specifying base types is mandatory even if they can be inferred from program code. The integration of logical predicates into the type system and building language around refinements potentially give us new ways of solving problems. In this paper, we attempt to design a language with a novel approach to type refinements.\nGeneralization of Sets, Types, and Functions The syntactic and semantic possibilities of systems with refinement types can be extended by unifying the approach to the usage of types, sets, and functions. Let\u0026rsquo;s see what we can do. We use types to annotate values to limit them to some set of values. Firstly, we can do exact same thing with sets.\nx : Int y : {1, 2, 3, 4, 5} In this example, we set x to be a variable of base type of integers and y to be in a set.\nWe can apply the same approach to predicates:\nEven x = (x % 2 = 0) a : Even // suppose Lowercase is predicate for lowercase strings myString : Lowercase x = 0 As can be seen from these examples, predicates and sets are possible to be used literally in place of types: there is no special syntax to distinguish them. To make such behaviour possible, we should introduce a program entity that generalizes predicates, types, and sets, and takes a value as an argument and returns it if the particular condition is met. If the predicate is not satisfied, value should not be returned and this case should be considered as type error.\nNow let\u0026rsquo;s see how these definitions can be used inside functions.\nmyFunction (x : Even) = div x 2 Successful type checking when using this function implies that intersection of domain of function (expected type of argument) with actual argument is non-empty.\nIn the designed programming language, usage of these unified program entities is carried out by the same generalized operations: intersection, union and other, including user-defined operations. Another important feature is the ability to use arbitrary functions, including anonymous ones, at the type level.\nHere we show some fragments of the program code that illustrates these features.\nNat = Int, (\u0026gt;=0) In this example, we define type of natural numbers as an intersection of integer base type and positive predicate expressed with partially applied more-or-equal operator. Let\u0026rsquo;s use them in the defininition of a function.\nmyFunction y (x : Even, Nat {1, 2, 3, 4, 5} (\u0026lt;y)) : {Int \u0026amp; (\u0026gt;1)} = {x + 1} myFunction takes two arguments: y and x. The second argument is even natural number from the set containing concrete values. The second argument x is also less than the first argument y. Function returns a set of integers greater than 1. Return value is defined as set of all possible x increased by one. y here is constrained only by possibility to use of less-than operator.\nIn this language, type annotations do not forbid possibility of using functions inside them, if it is possible for them to compute their inverse functions. In some cases this is trivial and can done automatically (for example, increasing by a number, or returning a value that satisfies a condition), in other cases the behavior can be defined by user, making him able to prohibit some cases (such as division by zero for inverse of function of multiplying by number).\nHere is an example of more advanced usage of inverse functions.\nPerson = has firstName : String lastName : String parsePerson (firstName ++ \u0026quot; \u0026quot; ++ lastName) = Person firstName lastName input \u0026lt;- read String person : Person = if parsed = parsePerson input then parsed else Person \u0026quot;John\u0026quot; \u0026quot;Doe\u0026quot; At the first lines, we define Person record. Then, parsePerspon function is defined using pattern-matching-like syntax involving an inverse operation of concatenation function. Implementation of inverse concatenation (++) might be quite complex, but it can be made to parse more complex cases, such as regular expressions, or functions generating lists.\nAt the end of the listing, usage of parsePerson is shown. If input string wasn\u0026rsquo;t matched with parsePerson\u0026rsquo;s pattern, default value specified by alternative branch of the if expression.\nImplementation As a prototype implementation of the programming language, we developed static typechecker. It can also work as an interpreter and read-eval-print loop to analyze evaluation of expressions in this programming language, but we still can\u0026rsquo;t call it a full implementation of an interpreter as we still have not fully designed the input-output system and now use impure functions as placeholder for input and output in programs.\nThe interpreter converts the text of a program into a system of judgments about variables. The system can be checked by an SMT solver, and normalized to specific values ​​(if there is enough information to do this), dynamically evaluating expressions of the language.\nWe chose C++as language of implementation. Source code of implementation is available in our repository on GitHub . At the moment of writing this paper, the most actual code is in branch cast-eval.\nLet\u0026rsquo;s point out main aspects of architecture of this type checker.\nAt current stage, implementation can be considered as naive, as it mostly involves evaluating every expression (including types and computations at the type level) using wide set of pre-defined operations, and the fact that entities of this language are based around inheritance hierarchy and utilizing C++ type system and templates.\nWe can divide the architecture of interpreter into two parts: \u0026ldquo;expressions\u0026rdquo; and \u0026ldquo;system\u0026rdquo;. There are also tools for parsing and running read-eval-print loop, debugging language\u0026rsquo;s behaviour, etc.\nExpressions part contains around 44 classes describing logic of constructing, using and combining language\u0026rsquo;s entities. Code contained in second category is defining how basic computations and environment work.\nFuture Work The usage of arbitrary functions in type annotations of a language with static typing is not possible due to the fact that static typechecker might not have enough information about dynamic variables. To retain this possibility, it is required to introduce dynamic language elements: the use of gradual typing would allow to seamlessly combine static and dynamic checks, leaving the latter for the runtime. Gradual types can also be combined with refinement types.\nOne of the nearest steps is to implement separating the stage of static typechecking from runtime checks by introducing gradual typing, and investigation of possible problems.\nWe will also explore embedding an SMT solver such as Z3 into language\u0026rsquo;s type system for solving complex systems. We also plan to carry research on other language possibilities.\nReferences  Refinement types for secure implementations, J. Bengtson and K. Bhargavan and C. Fournet and A. D. Gordon and S. Maffeis Bounded Refinement Types - Niki Vazou and Alexander Bakst and Ranjit Jhala Gradual Refinement Types - Nicolás Lehmann and Éric Tanter Gradual Typing for Functional Languages - Jeremy G. Siek and Walid Taha Abstracting Gradual Typing - Ronald Garcia and Alison M. Clark and Éric Tanter Liquid Intersection Types - Mário Pereira and Sandra Alves and Mário Florido, Union, Intersection, and Refinement Types and Reasoning About Type Disjointness for Secure Protocol Implementations - Backes, Michael and Hriţcu, Cătălina and Maffei, Matteoa Refinement types for ML - Tim Freeman and Frank Pfenning LiquidHaskell: Experience with Refinement Types in the Real World - Niki Vazou and Eric L. Seidel and Ranjit Jhala ","permalink":"https://kvachev.com/blog/posts/c-of-x-intro/","summary":"\u003ch1 id=\"design-and-implementation-ofnbspprogramming-language-with-generalized-sets-types-and-functions-asnbspfirst-class-values\"\u003eDesign and Implementation of Programming Language with Generalized Sets, Types, and Functions as First-Class Values\u003c/h1\u003e","title":"c(x) intro"}]