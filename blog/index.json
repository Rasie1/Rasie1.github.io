[{"content":"Grids are great for tactical gameplay of turn-based games because they allow discrete movement steps. That means that you can bind positioning to other resources such as movement points, action points, food, etc. Grids divide the infinite variety of movement options into a few specific ones, which can be considered separately by the player\u0026rsquo;s tactical mind. The most popular grid types are hexes and squares. But what about triangles?\nYour browser does not support the video tag.  Types of Grids: Comparison We are perfectly familiar with square and hex grids, as most turn-based games use one of them. Both have upsides and downsides. I will go through each of these and include the triangle grid in comparison.\n Visuals Square grids will contribute to visuals for non-natural environments, such as towns, dungeons, streets, and building interiors.\nHex grids look nice with natural environments instead, improving the realism of curvy things, such as islands, mountains, small roads, etc.\nIn the case with looks, triangle grids lie in between: like squares, they allow straight lines and walls without half-tiles, and like hexes, they allow more curvy environments. In fact, triangle grids contain both in itself! You can even have rhombus (huge) and hex (colossal) creatures on top of the triangle grid, like this:\n On top of that, it has a bonus: like the square grid, it can contain bigger and smaller grids in itself.\nThe only visual downside before the square grid is that it can\u0026rsquo;t express rectangle buildings. In this case, the same cheat from the hex grid can be used: use half tiles. A blocking object (wall) goes through half of the tile and the tile is blocked completely.\n There are also two special cases that make triangles shine. The first is line formations. When the second row of spearmen/riflemen stays between the first, like on the picture above, they can attack enemy formation too without a friend obstructing the view.\nSo it\u0026rsquo;s possible to directly represent lines of soldiers on triangular grids; formations will also have the ability to rotate in 6 directions. But this point applies to hex grids too, it\u0026rsquo;s just that the second row will be further away from enemies, and with triangles, enemies in front of the formations are diagonally-adjacent to the second row. I\u0026rsquo;ll tell you more about diagonals and diagonal distances in a minute.\n Another thing is citadels/bastions. These angles allow more convenient defenses, and fortifications were often built this way throughout history. In Colossal Citadels I made walls and houses follow the triangular grid and I love how these procedurally-generated castles turned out:\n Directions and Adjacent Tiles The number of tactical options (movements, attacks, ranged straight-line attacks) depends on the type of grid. It also depends on whether or not you allow diagonal directions. Let\u0026rsquo;s count how many non-diagonal directions each grid type allows:\n  Square grid: 4 adjacent tiles, 4 directions Hex grid: 6 adjacent tiles, 6 directions Triangle grid: 3 adjacent tiles, 6 directions  Restricting the number of options would make sense in a tight puzzle-like tactics game, and in bigger strategy games you might want to increase the variety of options to depend less on micro tactics on movement.\nDirections And Adjacent Tiles: Diagonals Some games increase these numbers by allowing diagonal tiles and directions. This is where triangle grids overcome other variants!\n  Square grid: 8 adjacent tiles, 8 directions Hex grid: 6 adjacent tiles, 6 directions Triangle grid: 12 adjacent tiles, 12 directions  So, if you want to have more options, triangle grids with diagonals are a good choice. Ranged \u0026ldquo;line\u0026rdquo; attacks also look slightly better because they\u0026rsquo;re not alternating as with the hex grids; be sure to highlight the lines in 6 straight diagonals, or it will look not so good.\nDistances   Hex grids are very good at estimating the closest path - you can naturally see the closest point. Square grids without diagonals are not so convenient, but distances are always easy to calculate. Triangle grids without diagonals are fine, but there is an issue when you have an opposing triangle: it takes 3 steps to move to it. This might look weird and unnatural. We can fix this by introducing diagonals: allow jumping to the opposing triangle at the cost of 2 instead of three. Then, triangular grid becomes convenient to use and more realistic:   You can find calculating functions for all distances (and explanations) in the end of this article. By the way, I believe I was the first to mention this and the next kind of triangle diagonal distances in the internet here - it links to another cool article by BorisTheBrave. But these grids are simple stuff in my opinion, and most possibly, board game developers who explored triangle grids already have considered it long ago.\nSo, this way of calculating distance is quite fine for movements, but for less edgy shapes (for example, buildings), you might want to have something even simpler: full diagonal distances. Treat all tiles that touch the current triangle with one of the vertices as a distance of 1.\n Unfortunately, this approach is not a panacea: it\u0026rsquo;s not that beautiful for movement, because a moving unit can cheat a little bit and cover up to two times more tiles than in previous distance measures! Can you figure out how? But this type of distance is very good for ranged attacks and zones! So, I would suggest using either the previous formula, or both: full diagonals for ranges and diagonal shortcut for movements.\nHeightmap Terrains This is not a gameplay point, but it\u0026rsquo;s still worth mentioning. There is a way of drawing terrain meshes with triangles instead of quads. This way can save some percentage of triangle count and fixes some other issues automatically. If terrain tiles are tied to gameplay, this is going to look interesting. I\u0026rsquo;ve not seen a triangular grid voxel minecraft-like game yet!\n How To Use Triangular Grid Red Blob Games\u0026rsquo;s article provides a lot of thoughts on representations of triangle grid, but I\u0026rsquo;ll just use the best one and supply it with a lot of common useful operations on it.\nCoordinate Representation The most convenient option is to represent it as square grid coordinates PLUS a number that means half-square - 0 or 1.\nstruct Pos { int x, y, s; }; Conversions Conversions between index, coordinates, and 2D world coordinates are going to be the most common operations.\nIndex \u0026lt;-\u0026gt; Coordinates int toIndex(const Pos\u0026amp; pos, int gridWidth) { return pos.x * 2 + pos.y * gridWidth * 2 + pos.s; } Pos fromIndex(int i, int gridWidth) { return Pos{(i / 2) % gridWidth, (i / 2) / gridWidth, i % 2}; } World \u0026lt;-\u0026gt; Coordinates struct Vec2 { float x, y; }; We will need some constants for representing tile size in world space. I use these:\nnamespace TriangleConstants { const float Height = 150.f; const float Side = 173.20508075689f; } Vec2 gridToWorld( const Pos\u0026amp; pos, float worldspaceTriangleSide, float worldspaceTriangleHeight) { return Vec2{ pos.x * worldspaceTriangleSide + pos.y * worldspaceTriangleSide / 2.f, pos.y * worldspaceTriangleHeight }; } Pos worldToGrid(const Vec2\u0026amp; pos) { float y = std::get\u0026lt;1\u0026gt;(pos) / TriangleConstants::Height; float x = std::get\u0026lt;0\u0026gt;(pos) / TriangleConstants::Side - y / 2.f; bool s = (x - floorf(x) + y - floorf(y)) \u0026gt; 1.f; return Pos{int(x), int(y), int(s)}; } Trianglular Grid \u0026lt;-\u0026gt; Square Grid It\u0026rsquo;s just as simple as taking x and y components and adding or removing third coordinate from them.\nTriangle Tile Distance To calculate simple tile distance you can use Manhattan distance with addition of third component difference.\nint distance(const Pos\u0026amp; a, const Pos\u0026amp; b) { auto dx = a.x - b.x; auto dy = a.y - b.y; auto ds = a.s - b.s; return abs(dx) + abs(dy) + abs(dx + dy + ds); } The logic behind this formula is that first you need to convert your coordinates to intermediate representation (adx, adx, adz), that reflects distances from initial point on three axes, each one parallel to one side of a triangle. Since it is just a taxicab distance, you need to just sum three components up.\nConvenient distance functions are a bit more complex:\nDiagonal Triangle Tile Distance (Shortcuts) To allow movement through diagonal, you have to subtract the minimum of three distance components from the previous formula. Why is that and how did I find this? That information is lost\u0026hellip; Probably, I just noticed it from staring at triangular grid for too long.\nint triangleDistanceDiagonal(const TilePosition\u0026amp; a, const TilePosition\u0026amp; b) { auto dx = a.x - b.x; auto dy = a.y - b.y; auto ds = a.s - b.s; auto adx = abs(dx); auto ady = abs(dy); auto adz = abs(dx + dy + ds); auto m = std::min({adx, ady, adz}); return adx + ady + adz - m; } Diagonal Triangle Tile Distance (Full) This is much simpler. To treat all diagonal tiles as distance one, you have to find maximum of all three components instead:\nint triangleDistanceFullDiagonal(const TilePosition\u0026amp; a, const TilePosition\u0026amp; b) { auto dx = a.x - b.x; auto dy = a.y - b.y; auto ds = a.s - b.s; auto adx = abs(dx); auto ady = abs(dy); auto adz = abs(dx + dy + ds); return std::max({adx, ady, adz}); } Source Code All these functions plus some lesser ones, for example, calculating adjacent coordinate with or without diagonals, are included in my tiny header library. Feel free to use it, it\u0026rsquo;s published under CC0.\nYour browser does not support the video tag.  Conclusion Triangular grids are a fantastic option too. As far as I know, there are no released games that make use of triangle grids yet. Maybe my project (from the screenshots above) will be the first? There are some board games - someone even tried to play Go on triangular grids.\nHowever, the design of my game doesn\u0026rsquo;t need precise movement controls. You still play with grids with abilities and town-building, but the positioning of creatures is automatic. So, the space for classic turn-based tactics on triangle grids will be still open.\nThere are also other bizarre and irregular grid types. I can see some interesting gameplay ideas coming out from these, e.g. buildings can only go on big tiles, or smaller tiles are for \u0026ldquo;upgrades\u0026rdquo; that apply to big tiles, and so on.\n ","permalink":"https://kvachev.com/blog/posts/triangular-grid/","summary":"\u003cp\u003eGrids are great for tactical gameplay of turn-based games because they allow discrete movement steps. That means that you can bind positioning to other resources such as movement points, action points, food, etc. Grids divide the infinite variety of movement options into a few specific ones, which can be considered separately by the player\u0026rsquo;s tactical mind. The most popular grid types are hexes and squares. But what about triangles?\u003c/p\u003e","title":"Triangle Grids"},{"content":"This fog looks almost like volumetrics but takes almost no time to render\nYour browser does not support the video tag.  Intro I\u0026rsquo;ve been requested many times since I posted this video on social networks to write an article about how this fog works. Ok, this will be a tutorial with some details about every part of implementation, so that you can make your own fog with similar steps. Coefficients will have to be different depending on your world size, slopes, camera heights and angles, so simply copying this implementation won\u0026rsquo;t work.\n Fog brings a lot of atmosphere into photos, 3d environments, games, etc. Fancy-looking fog implementations are still an open issue:\n  volumetrics look insanely good and flexible but take ages to render\n  atmospheric fog is useful only for decorating far landscapes, you can\u0026rsquo;t have different fog heights at the same time\n  And this solution - I would call it \u0026ldquo;Fog Mesh\u0026rdquo; - is not perfect too, but it would work very well for top-down games: you can get beautiful fading, all kinds of animations, and have it rendered with almost zero cost.\nThis approach is useful both for implementing fog of war for strategy games and for just decoration purposes. Unfortunately, it won\u0026rsquo;t fit first-person games (unless your character is looking down from a helicopter, for example) - it will have some visual artifacts when you\u0026rsquo;re looking from inside the fog! Yet, I hope to see more usages of this for top-down games.\nThe Composition  The fog mesh implementation can be broken down into:\n heightmap mesh that covers your terrain gaussian blur on heightmap (in mesh or in material, depending on what you need from the fog) depth fade \u0026amp; translucency in mesh material world-aligned texture (unless you want a flat-colored fog) in mesh material change of opacity depending on the distance to the camera in mesh material  So, as you see, nothing fancy, just a careful combination of parameters, mined out using a lot of iteration - you will definitely need to tweak the parameters for your terrain size, height, and camera angles. I\u0026rsquo;ll go through each part in detail. But first, let\u0026rsquo;s look at how to control it.\n Different fog colors can make a great contribution to environment flavor.\n Representation/Heightmap Input:\n You\u0026rsquo;ll need a heightmap of your terrain - texture/array of its height locations. If your terrain is flat, skip this step. You\u0026rsquo;ll need a texture/array of fog data - it can be either bools or floats. In Colossal Citadels, the fog of war is gradual and there can be fog/visibility with a value of 0.42, but usually in strategies with incomplete information you either have fog of war in a certain location or you don\u0026rsquo;t have it. Color, texture, etc will go to material parameters, but you can use vertex buffers of the fog mesh to pass color to the material as well. Just make sure they\u0026rsquo;re smooth enough  Intermediate representation:\nIf you don\u0026rsquo;t have to update the fog every frame, then you can just put fog vertices into the vertex buffer along with some additional data. You will still be able to smoothly blend between two fog states: just swap two fog meshes with world position offset animation in shader.\nYour browser does not support the video tag.  In case if you have a real-time game, which reveals a little part of fog of war every frame, you can make fog use data from a RenderTarget and draw to it instead. Then GPU will have to take some costs of processing visibility and blurring - that\u0026rsquo;s the tradeoff of such flexibility. In my example, fog changes only once in a while, and you don\u0026rsquo;t have to use RenderTarget to blend smoothly.\nFog Visibility Preprocessing This is the simplest step. Here is how I convert fog value to special intermediate values:\nstd::vector\u0026lt;float\u0026gt; visibilityA; std::vector\u0026lt;float\u0026gt; visibilityB; for (int y = 0; y \u0026lt; worldHeight; ++y) for (int x = 0; x \u0026lt; worldWidth; ++x) { int i = tileCoordsToFogMeshIndex(x, y); auto i1 = fogMeshIndexToTileIndex(i); const auto\u0026amp; tile = map-\u0026gt;GetTile(i1); auto modifyAlpha = [\u0026amp;](int coord, const TileInfo\u0026amp; tile){ if (tile.visibility() \u0026gt;= 0.f) { float visibility = std::clamp(tile.visibility(), 0.f, 1.f); visibility = 1.f - visibility; visibility *= visibility; visibility = 1.f - visibility; // this part is specific to Colossal Citadels and reduced visibilites  // around the objects - areas with little amount of fog should look completely clear  int newAlpha = static_cast\u0026lt;int\u0026gt;(visibilityA[coord]) - static_cast\u0026lt;int\u0026gt;(visibility * 42.5f) - 16; visibilityA[coord] = (newAlpha \u0026lt; 0) ? 0 : newAlpha; visibilityB[coord] = visibility * 255.f; } }; modifyAlpha(i, tile1); modifyAlpha(i + 1, tile1); modifyAlpha(i + fogWidth, tile1); modifyAlpha(i + 1 + fogWidth, tile1); } Next, apply a reasonable amount of blur to these fog values:\niir_gauss_blur\u0026lt;float, 1\u0026gt;(worldWidth, worldHeight, visibilityA.data(), RenderingParameters.Other[\u0026#34;FogVisibilityBlur\u0026#34;]); iir_gauss_blur\u0026lt;float, 1\u0026gt;(worldWidth, worldHeight, visibilityB.data(), RenderingParameters.Other[\u0026#34;FogVisibilityBlur\u0026#34;]); All these magic values will have to be tweaked for your project. Here are some additional magic formulas that go right after:\nfor (auto\u0026amp; b: visibilityB) { b /= 256.f; b = -b * 210.f; } for (auto\u0026amp; a: visibilityA) { a /= 256.f; a = std::tanf((1.f - a) * 1.571f) * 3.f; } Note that if you use RenderTargets, you\u0026rsquo;ll have to put similar code to fog material instead.\nI use TexCoord buffers to feed fog values into material:\nTangents.SetNum(verticesInFog); TexCoords.SetNum(verticesInFog); for (int y = 0; y \u0026lt; worldHeight; ++y) for (int x = 0; x \u0026lt; worldWidth; ++x) { int idx = tileCoordsToFogMeshIndex(x, y); TexCoords.SetTexCoord(idx, FVector2D(visibilityB[idx], visibilityA[idx])); } Depth Fade This is the core of the fog. We already have difficult formula for FadeDistance. We connect output of DepthFade straight to opacity of the translucent material of the fog mesh.\n Camera Angles Note that on changing angles, fog becomes denser or dissappears - this might be not wanted for implementing fog of war, which needs to clearly show where the fog starts. Also, it looks weird when you move the camera and the fog \u0026ldquo;moves\u0026rdquo; too. We\u0026rsquo;ll already mostly fixed this using previous formulas, but it camera height also messes it up. Here is one more step that makes it look better on zoom in.\n Note that in Colossal Citadels map blends between isometric and almost orthographic projection by changing field of view. For most cameras, these coefficients would be insane, so tweak them!\nTexture Your browser does not support the video tag.  This is the most artistic step - you can put any texture you want - just make sure to put it on a world-aligned virtual plane, or you will observe \u0026ldquo;artifacts\u0026rdquo; on height slopes due\nVirtual Planes I made two virtual planes using shifting perlin noise texture. Because two planes have some distance between them, it looks ridiculously good, like the fog is 3-dimensional!\nYour browser does not support the video tag.  We need to draw a plane on top of material transform the texture so that it looks like a plane parallel to the ground. Luckily, unreal engine implements that already:\n Combination of Noises These two values from previous snipped need to be combined:\n This goes to Emissive Color.\nOn the snipped above I also do do blend between texture and flat color - in my opinion it looks better on very close zoom in.\nYour browser does not support the video tag.  Smooth update of fog? Yes, you can blend between two fog states, for example, when you just moved your units and revealed some new territory. There are a variety of ways of doing that:\n initially store fog position in a texture that is used as a heightmap in the shader of fog \u0026ldquo;plane\u0026rdquo;. Draw on this position directly or blend between two images. Have two meshes that gradually swap between each other  Useful Additions It\u0026rsquo;s also possible to embed shadows and godrays here after some additional work - maybe I\u0026rsquo;ll try these someday. You can also have gradual blends between different colors (depending or tile data or just with fog shader).\nIssues The biggest issue is that fog edges still can cut abruptly if you look at it from an angle. You are also going to observe this issue if the slope is too big, for example you have too high mountains.\nHere is what I mean by unwanted angles:\n It\u0026rsquo;s possible to at least partially overcome this by:\n forbidding certain camera angles. render fog mesh to stencil or depth buffer and blur edges or/and screen in postprocessing  Fresnel won\u0026rsquo;t look good unless you have an inadequate amount of vertices.\nConclusion That\u0026rsquo;s it! I hope you got an understanding on how to create a similar fog.\n","permalink":"https://kvachev.com/blog/posts/fog-for-topdown-games/","summary":"\u003cp\u003eThis fog looks almost like volumetrics but takes almost no time to render\u003c/p\u003e","title":"Fog for Top-Down Games"},{"content":"There was some unsolved issues in my old Medium article, dozens of people viewed it every day and tried to use it nevetheless, so I deleted it. Now there are no issues, and it\u0026rsquo;s possible to link and flawlessly use protobuf without restrictions\nBefore we start, I suggest you to reconsider using grpc - you can use nice built-in Unreal Engine\u0026rsquo;s automatic serialization, replication, and RPCs with USTRUCTs. Even though UPROPERTIES have blunt capabilities - nested arrays and maps are not allowed (?), you can\u0026rsquo;t have recursive structures (??), and there are no basic things such as variants and optionals (???), it will be much more efficient to use TArrays, TMaps, and FStrings directly. You will need to convert containers and strings anyway to pass them to the engine - it\u0026rsquo;s better to store and send them directly.\nBut sometimes this is not the case, and you have to use it for accessing some other services, or you need the standard library, or something else. In this case, you might stumble into an insane amount of problems, such as link conflicts, dynamic loading issues, macro redefinitions. Luckily, this is all solvable.\nJust sharing an example project won\u0026rsquo;t work because protobuf-generated files should be built with the same version of protobuf you\u0026rsquo;re linking with, and linked libraries depend on specific windows libraries, and you have to do some specific steps every time you generate proto files. One could probably automate that someday.\nInstall GRPC Correctly Link statically - it works in newer versions. Don\u0026rsquo;t ever try to link protobuf dynamically - it\u0026rsquo;s badly designed and you will get many unsolvable issues this way. My protobuf version is 3.19.4, but try the latest version at first.\nFor Windows, I used vcpkg to install this specific triplet:\n./vcpkg.exe install grpc:x64-windows-static-md Link it to your project Then you have to link grpc and all dependencies (protobuf, zlib, openssl, c-ares, and possibly some more) with your Unreal Engine project. For simplicity, I just merged all include and lib directories from vcpkg\u0026rsquo;s installed directory.\ncp installed/\u0026lt;library\u0026gt;x64-windows-static-md/lib/* ../MyProject/ThirdParty/lib Put this into MyProject.Build.cs\nPublicIncludePaths.Add(Path.Combine(ThirdPartyPath, \u0026#34;include\u0026#34;)); string LibrariesPath = Path.Combine(ThirdPartyPath, \u0026#34;lib\u0026#34;); DirectoryInfo d = new DirectoryInfo(LibrariesPath); FileInfo[] Files = d.GetFiles(\u0026#34;*.lib\u0026#34;); foreach (FileInfo file in Files) { PublicAdditionalLibraries.Add(Path.Combine(LibrariesPath, file.Name)); } Definitions.Add(string.Format( \u0026#34;WITH_GRPC_BINDING=1\u0026#34;)); Illegal Library Movements Then we\u0026rsquo;ll have to make a couple of weird steps.\nFirst, if you have libcurl (or any other library that makes use of SSL) linked to your Unreal Engine project, you will get conflicts with openssl in your new lib dir. To resolve them you can delete these from ThirdParty/lib dir:\nrm libcrypto.lib libssl.lib If you\u0026rsquo;re actually going to use SSL channels in grpc, then it\u0026rsquo;s better to make sure that openssl versions are matching (and that\u0026rsquo;s a different story), or it\u0026rsquo;s undefined behaviour.\nSecond weird step: libraries depend on these libraries from Windows distribution: crypt32.lib iphlpapi.lib userenv.lib psapi.lib ws2_32.lib. Find them on your C drive (they can be in Windows SDK, for example) and either link against them in Strategy.Build.cs or just copy them into lib directory.\nCompile the project to see if it works!\nUsage Your .proto files should contain this code:\noption optimize_for = LITE_RUNTIME;option cc_enable_arenas = true;Then you just usually compile your protos with protoc from vcpkg\u0026rsquo;s installed directory.\n\u0026#34;installed/tools/protobuf/protoc.exe\u0026#34; -I . --grpc_out=cpp --plugin=protoc-gen-grpc=\u0026#34;/full/path/to/installed/tools/grpc/grpc_cpp_plugin.exe\u0026#34; cc/MyProject/* \u0026#34;installed/tools/protobuf/protoc.exe\u0026#34; -I . --cpp_out=cpp cc/MyProject/* For every protoc invocation Then you have to edit every .cc file generated (not the headers) and add some code before first include and some code after first include.\nThis goes before the first include:\n#include \u0026#34;EnableGrpcIncludes.h\u0026#34;This goes after the last include:\n#include \u0026#34;DisableGrpcIncludes.h\u0026#34;I will give the contents of these files at the end of the article: add them to your project.\nFor every file in your project If you include any generated headers or just protobuf/grpc headers, you\u0026rsquo;ll have to wrap them with #include \u0026quot;EnableGrpcIncludes.h\u0026quot; and #include \u0026quot;DisableGrpcIncludes.h\u0026quot; too.\nEnableGrpcIncludes.h #define GRPC_USE_PROTO_LITE 1  #ifndef WORKAROUND_SYMBOL_MEMORY_BARRIER #define WORKAROUND_SYMBOL_MEMORY_BARRIER static void MemoryBarrier() {} #endif  #pragma warning (disable : 4800) // forcing value to bool true or false #pragma warning (disable : 4125) // decimal digit terminates octal escape sequence #pragma warning (disable : 4647) // behavior change __is_pod has different value in previous version #pragma warning (disable : 4668) // \u0026#39;symbol\u0026#39; is not defined as a preprocessor macro, replacing with \u0026#39;0\u0026#39; for \u0026#39;directives\u0026#39; #pragma warning (disable : 4582) // constructor is not implicitly called #pragma warning (disable : 4583) // destructor is not implicitly called #pragma warning (disable : 4946) // reinterpret_cast #pragma warning (disable : 4005) // macro redefinition #pragma warning (disable : 4005) // initializers put in library initialization area #define GOOGLE_PROTOBUF_NO_RTTI true #ifndef __ANDROID__ #include \u0026#34;Windows/AllowWindowsPlatformTypes.h\u0026#34; #endif #pragma intrinsic(_InterlockedCompareExchange64) #define InterlockedCompareExchangeAcquire64 _InterlockedCompareExchange64 #define InterlockedCompareExchangeRelease64 _InterlockedCompareExchange64 #define InterlockedCompareExchangeNoFence64 _InterlockedCompareExchange64 #define InterlockedCompareExchange64 _InterlockedCompareExchange64 DisableGrpcIncludes.h #ifndef __ANDROID__ #include \u0026#34;Windows/HideWindowsPlatformTypes.h\u0026#34;#endif (if you want, you can re-enable warnings that were disabled in the first file)\nConclusion That\u0026rsquo;s it, now it should work flawlessly: both serving and making requests. If you have any issues, message me.\nProbably some libraries from lib can be deleted too, because not everything from there is a dependency.\n","permalink":"https://kvachev.com/blog/posts/grpc-with-unreal-engine/","summary":"\u003cp\u003e\u003cem\u003eThere was some unsolved issues in my old Medium article, dozens of people viewed it every day and tried to use it nevetheless, so I deleted it. Now there are no issues, and it\u0026rsquo;s possible to link and flawlessly use protobuf without restrictions\u003c/em\u003e\u003c/p\u003e","title":"GRPC with Unreal Engine"},{"content":"Design and Implementation of Programming Language with Generalized Sets, Types, and Functions as First-Class Values This is a very formal and old article about one of my old project of designing and making a language with mad, nearly esoteric, but still cool type system with composable gradual refinements. I felt like it should not be forgotten and put it into this blog; I will write some expansions of ideas described here soon.\nAbstract We present several design ideas for an experimental programming language featuring flexible and expressive type system that ensures error prevention while preserving readability, maintainability and convenience of writing code. We argue that this goal can be achieved by unifying syntactic approach to types, sets, and functions in order to make them composable and interchangeable, and by implementing possibility to use all of them as first class citizens. In this paper we give a high-level overview of the main language features along with some implementation details. We conclude with plans for future work.\nIntroduction Many modern programming languages, such as Haskell, Scala, Agda, use rich type systems for preventing defects and specifying requirements for program entities and operations on them, increasing expressiveness and usability. There are two well-known approaches to advancing type systems, that draw much attention nowadays: dependent types and refinement types. While dependent types allow types to depend on values, refinement types provide an ability to augment types with logical predicates. Dependent types typically require higher amounts of assistance by programmers. Opposing to them, type systems based on refinement types have a high degree of automation and expressiveness of verification of program code. Refinement types do not require detailed proofs as systems with dependent types do, and they allow user to conveniently construct the constraints. In many existing implementations of systems with refinement types, the refinements are orthogonal to the base types system of the language. For example, in LiquidHaskell, which is an extension of Haskell programming language, constructions with refinement types are specified in the form of special annotations and used exclusively for static validation of the source code. In refinement type annotations specifying base types is mandatory even if they can be inferred from program code. The integration of logical predicates into the type system and building language around refinements potentially give us new ways of solving problems. In this paper, we attempt to design a language with a novel approach to type refinements.\nGeneralization of Sets, Types, and Functions The syntactic and semantic possibilities of systems with refinement types can be extended by unifying the approach to the usage of types, sets, and functions. Let\u0026rsquo;s see what we can do. We use types to annotate values to limit them to some set of values. Firstly, we can do exact same thing with sets.\nx : Int y : {1, 2, 3, 4, 5} In this example, we set x to be a variable of base type of integers and y to be in a set.\nWe can apply the same approach to predicates:\nEven x = (x % 2 = 0) a : Even // suppose Lowercase is predicate for lowercase strings myString : Lowercase x = 0 As can be seen from these examples, predicates and sets are possible to be used literally in place of types: there is no special syntax to distinguish them. To make such behaviour possible, we should introduce a program entity that generalizes predicates, types, and sets, and takes a value as an argument and returns it if the particular condition is met. If the predicate is not satisfied, value should not be returned and this case should be considered as type error.\nNow let\u0026rsquo;s see how these definitions can be used inside functions.\nmyFunction (x : Even) = div x 2 Successful type checking when using this function implies that intersection of domain of function (expected type of argument) with actual argument is non-empty.\nIn the designed programming language, usage of these unified program entities is carried out by the same generalized operations: intersection, union and other, including user-defined operations. Another important feature is the ability to use arbitrary functions, including anonymous ones, at the type level.\nHere we show some fragments of the program code that illustrates these features.\nNat = Int, (\u0026gt;=0) In this example, we define type of natural numbers as an intersection of integer base type and positive predicate expressed with partially applied more-or-equal operator. Let\u0026rsquo;s use them in the defininition of a function.\nmyFunction y (x : Even, Nat {1, 2, 3, 4, 5} (\u0026lt;y)) : {Int \u0026amp; (\u0026gt;1)} = {x + 1} myFunction takes two arguments: y and x. The second argument is even natural number from the set containing concrete values. The second argument x is also less than the first argument y. Function returns a set of integers greater than 1. Return value is defined as set of all possible x increased by one. y here is constrained only by possibility to use of less-than operator.\nIn this language, type annotations do not forbid possibility of using functions inside them, if it is possible for them to compute their inverse functions. In some cases this is trivial and can done automatically (for example, increasing by a number, or returning a value that satisfies a condition), in other cases the behavior can be defined by user, making him able to prohibit some cases (such as division by zero for inverse of function of multiplying by number).\nHere is an example of more advanced usage of inverse functions.\nPerson = has firstName : String lastName : String parsePerson (firstName ++ \u0026quot; \u0026quot; ++ lastName) = Person firstName lastName input \u0026lt;- read String person : Person = if parsed = parsePerson input then parsed else Person \u0026quot;John\u0026quot; \u0026quot;Doe\u0026quot; At the first lines, we define Person record. Then, parsePerspon function is defined using pattern-matching-like syntax involving an inverse operation of concatenation function. Implementation of inverse concatenation (++) might be quite complex, but it can be made to parse more complex cases, such as regular expressions, or functions generating lists.\nAt the end of the listing, usage of parsePerson is shown. If input string wasn\u0026rsquo;t matched with parsePerson\u0026rsquo;s pattern, default value specified by alternative branch of the if expression.\nImplementation As a prototype implementation of the programming language, we developed static typechecker. It can also work as an interpreter and read-eval-print loop to analyze evaluation of expressions in this programming language, but we still can\u0026rsquo;t call it a full implementation of an interpreter as we still have not fully designed the input-output system and now use impure functions as placeholder for input and output in programs.\nThe interpreter converts the text of a program into a system of judgments about variables. The system can be checked by an SMT solver, and normalized to specific values ​​(if there is enough information to do this), dynamically evaluating expressions of the language.\nWe chose C++as language of implementation. Source code of implementation is available in our repository on GitHub . At the moment of writing this paper, the most actual code is in branch cast-eval.\nLet\u0026rsquo;s point out main aspects of architecture of this type checker.\nAt current stage, implementation can be considered as naive, as it mostly involves evaluating every expression (including types and computations at the type level) using wide set of pre-defined operations, and the fact that entities of this language are based around inheritance hierarchy and utilizing C++ type system and templates.\nWe can divide the architecture of interpreter into two parts: \u0026ldquo;expressions\u0026rdquo; and \u0026ldquo;system\u0026rdquo;. There are also tools for parsing and running read-eval-print loop, debugging language\u0026rsquo;s behaviour, etc.\nExpressions part contains around 44 classes describing logic of constructing, using and combining language\u0026rsquo;s entities. Code contained in second category is defining how basic computations and environment work.\nFuture Work The usage of arbitrary functions in type annotations of a language with static typing is not possible due to the fact that static typechecker might not have enough information about dynamic variables. To retain this possibility, it is required to introduce dynamic language elements: the use of gradual typing would allow to seamlessly combine static and dynamic checks, leaving the latter for the runtime. Gradual types can also be combined with refinement types.\nOne of the nearest steps is to implement separating the stage of static typechecking from runtime checks by introducing gradual typing, and investigation of possible problems.\nWe will also explore embedding an SMT solver such as Z3 into language\u0026rsquo;s type system for solving complex systems. We also plan to carry research on other language possibilities.\nReferences  Refinement types for secure implementations, J. Bengtson and K. Bhargavan and C. Fournet and A. D. Gordon and S. Maffeis Bounded Refinement Types - Niki Vazou and Alexander Bakst and Ranjit Jhala Gradual Refinement Types - Nicolás Lehmann and Éric Tanter Gradual Typing for Functional Languages - Jeremy G. Siek and Walid Taha Abstracting Gradual Typing - Ronald Garcia and Alison M. Clark and Éric Tanter Liquid Intersection Types - Mário Pereira and Sandra Alves and Mário Florido, Union, Intersection, and Refinement Types and Reasoning About Type Disjointness for Secure Protocol Implementations - Backes, Michael and Hriţcu, Cătălina and Maffei, Matteoa Refinement types for ML - Tim Freeman and Frank Pfenning LiquidHaskell: Experience with Refinement Types in the Real World - Niki Vazou and Eric L. Seidel and Ranjit Jhala ","permalink":"https://kvachev.com/blog/posts/c-of-x-intro/","summary":"\u003ch1 id=\"design-and-implementation-ofnbspprogramming-language-with-generalized-sets-types-and-functions-asnbspfirst-class-values\"\u003eDesign and Implementation of Programming Language with Generalized Sets, Types, and Functions as First-Class Values\u003c/h1\u003e","title":"c(x) intro"}]